{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ferrum-network-documentation","title":"Ferrum Network Documentation","text":"<p>Ferrum Network enables value, data, and functional interoperability between every blockchain in the industry. Interoperability by Design.</p> <p>Ferrum Network's sophisticated solutions simplify the complexity of building a multichain solution and give developers and project owners a single entry point to every recognizable chain and network in the industry. We have thought about the pain points that arise when implementing interoperability as an afterthought in a multi-network / multichain world. </p> <p>With an ever-growing list of new EVM and non-EVM compatible chains coming to market, gaining traction, and providing value to segments of the global crypto audience, interoperability has become a core value for most projects. At Ferrum Network, we design from the ground up for interoperability.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#1-how-to-reset-metamask","title":"1. How to reset metamask?","text":"<p>Occasionaly on the testnet, you may have to reset metamask, to do so follow the instructions at https://support.metamask.io/hc/en-us/articles/360015488891-How-to-clear-your-account-activity-reset-account</p>"},{"location":"faq/#2-how-to-get-testnet-tokens","title":"2. How to get testnet tokens","text":"<p>Navigate to https://testnet.faucet.ferrumnetwork.io/</p>"},{"location":"learn/","title":"Ferrum Network Docs","text":"<p>Ferrum Network enables value, data, and functional interoperability between every blockchain in the industry.</p>"},{"location":"learn/#interoperability-by-design","title":"Interoperability by Design","text":"<p>Ferrum Network's sophisticated solutions simplify the complexity of building a multichain solution and give developers and project owners a single entry point to every recognizable chain and network in the industry. We have thought about the pain points that arise when implementing interoperability as an afterthought in a multi-network / multichain world. With an ever-growing list of new EVM and non-EVM compatible chains coming to market, gaining traction, and providing value to segments of the global crypto audience, interoperability has become a core value for most projects. At Ferrum Network, we design from the ground up for interoperability.</p> <p>You can read more about Ferrum Network and its mission here</p> <p>This documentation is focused on setting up the ferrum node, running miner and finaliser nodes, and developing applications that use the Quantum Portal for cross chain communication.</p> <p>For learning more about Ferrum network and Quantum portal, you can use the links below : </p> <ul> <li>About Ferrum Network</li> <li>Core Tech</li> <li>Whitepaper</li> </ul>"},{"location":"learn/#what-is-ferrum-network","title":"What is Ferrum Network","text":"<p>Ferrum network is an evm-compatible substrate parachain. A parachain is an application-specific data structure that is globally coherent and can be validated by the validators of the Relay Chain. They take their name from the concept of parallelized chains that run parallel to the Relay Chain.</p>"},{"location":"learn/#why-parachains","title":"Why Parachains?","text":"<p>Parachains are a solution to two fundamental problems in blockchains:</p> <p>Scalability: Having one blockchain for many purposes makes it difficult to scale as future implementations and upgrades will likely advantage some purposes and disadvantage others. On the other hand, having different blockchains will allow them to implement features themselves without affecting other chains. Flexibility: It is reasonable to state a blockchain either will be really good in solving one problem or not so good trying to solve many problems. A blockchain able to specialize in solving a specific problem has more leverage towards itself and its users. Parachains are purpose-built blockchains highly specialized and able to take advantage from each other by cooperation.</p> <p>You can read more about Parachains here: https://wiki.polkadot.network/docs/learn-parachains</p>"},{"location":"builders/connect-metamask/","title":"How to connect metamask to Ferrum Testnet","text":""},{"location":"builders/connect-metamask/#where-to-view-transactions","title":"Where to view transactions","text":"<p>Substrate Explorer : https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Ftestnet.dev.svcs.ferrumnetwork.io#/explorer</p>"},{"location":"builders/connect-metamask/#faucet","title":"Faucet","text":"<p>https://testnet.dev.svcs.ferrumnetwork.io/faucet/</p>"},{"location":"builders/connect-metamask/#config","title":"Config","text":"<p>Network Name : Ferrum Testnet</p> <p>RPC URL : http://testnet.dev.svcs.ferrumnetwork.io:8545</p> <p>ChainId : 26100</p> <p>Currency : tFRM</p>"},{"location":"builders/connect-metamask/#example","title":"Example","text":""},{"location":"builders/deploy-evm-contracts/","title":"Deploy solidity contracts","text":"<p>Ferrum network integrates the <code>frontier</code> libraries from substrate. This means you can deploy any solidity/evm compatible smart contract to the ferrum testnet.</p>"},{"location":"builders/deploy-evm-contracts/#deploy-solidity-contract-to-testnet","title":"Deploy solidity contract to testnet","text":"<p>Deploying a solidity contract to testnet, is similar to deployment to any evm chain, this can be done in numerous ways, we will highlight two examples of deployment below</p>"},{"location":"builders/deploy-evm-contracts/#using-hardhat","title":"Using Hardhat","text":"<p>To deploy to ferrum testnet using Hardhat, use the following config below</p> <pre><code>    ferrum_testnet: {\n      chainId: 26100,\n      url: \"https://testnet.dev.svcs.ferrumnetwork.io/rpc\",\n      allowUnlimitedContractSize: true,\n      gas: 10000000,\n    },\n</code></pre>"},{"location":"builders/deploy-wasm-contracts/","title":"Deploy ink! contracts","text":"<p>Ferrum network integrates the <code>contracts</code> pallet from substrate. This means you can deploy any wasm compatible contract to the ferrum testnet.</p>"},{"location":"builders/deploy-wasm-contracts/#ink-development","title":"Ink! Development","text":"<p>Ink! is a Rust eDSL developed by Parity. It specifically targets smart contract development for Substrate\u2019s pallet-contracts.</p> <p>Ink! offers Rust procedural macros and a list of crates to facilitate development and allows developers to avoid writing boilerplate code.</p> <p>It is currently the most widely supported eDSL, and will be highly supported in the future. (by Parity and builders community).</p> <p>Ink! offers a broad range of features such as:</p> <ul> <li>idiomatic Rust code</li> <li>Ink! Macros &amp; Attributes - #[ink::contract]</li> <li>Trait support</li> <li>Upgradeable contracts - Delegate Call</li> <li>Chain Extensions (interact with Substrate pallets inside a contract)</li> <li>Off-chain Testing - #[ink(test)]</li> </ul> <p>You can learn more about using ink! at https://use.ink/</p>"},{"location":"builders/deploy-wasm-contracts/#writing-an-ink-contract","title":"Writing an ink! contract","text":"<p>Example contract </p> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Creates a new flipper smart contract initialized with the given value.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -&gt; Self {\n            Self { value: init_value }\n        }\n\n        /// Creates a new flipper smart contract initialized to `false`.\n        #[ink(constructor)]\n        pub fn new_default() -&gt; Self {\n            Self::new(Default::default())\n        }\n\n        /// Flips the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn flip(&amp;mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn get(&amp;self) -&gt; bool {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        fn default_works() {\n            let flipper = Flipper::new_default();\n            assert!(!flipper.get());\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut flipper = Flipper::new(false);\n            assert!(!flipper.get());\n            flipper.flip();\n            assert!(flipper.get());\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::build_message;\n\n        type E2EResult&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;;\n\n        #[ink_e2e::test]\n        async fn it_works(mut client: ink_e2e::Client&lt;C, E&gt;) -&gt; E2EResult&lt;()&gt; {\n            // given\n            let constructor = FlipperRef::new(false);\n            let contract_acc_id = client\n                .instantiate(\"flipper\", &amp;ink_e2e::alice(), constructor, 0, None)\n                .await\n                .expect(\"instantiate failed\")\n                .account_id;\n\n            let get = build_message::&lt;FlipperRef&gt;(contract_acc_id.clone())\n                .call(|flipper| flipper.get());\n            let get_res = client.call_dry_run(&amp;ink_e2e::bob(), &amp;get, 0, None).await;\n            assert!(matches!(get_res.return_value(), false));\n\n            // when\n            let flip = build_message::&lt;FlipperRef&gt;(contract_acc_id.clone())\n                .call(|flipper| flipper.flip());\n            let _flip_res = client\n                .call(&amp;ink_e2e::bob(), flip, 0, None)\n                .await\n                .expect(\"flip failed\");\n\n            // then\n            let get = build_message::&lt;FlipperRef&gt;(contract_acc_id.clone())\n                .call(|flipper| flipper.get());\n            let get_res = client.call_dry_run(&amp;ink_e2e::bob(), &amp;get, 0, None).await;\n            assert!(matches!(get_res.return_value(), true));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn default_works(mut client: ink_e2e::Client&lt;C, E&gt;) -&gt; E2EResult&lt;()&gt; {\n            // given\n            let constructor = FlipperRef::new_default();\n\n            // when\n            let contract_acc_id = client\n                .instantiate(\"flipper\", &amp;ink_e2e::bob(), constructor, 0, None)\n                .await\n                .expect(\"instantiate failed\")\n                .account_id;\n\n            // then\n            let get = build_message::&lt;FlipperRef&gt;(contract_acc_id.clone())\n                .call(|flipper| flipper.get());\n            let get_res = client.call_dry_run(&amp;ink_e2e::bob(), &amp;get, 0, None).await;\n            assert!(matches!(get_res.return_value(), false));\n\n            Ok(())\n        }\n    }\n}\n</code></pre> <p>More examples can be found here : https://github.com/paritytech/ink-examples</p>"},{"location":"builders/deploy-wasm-contracts/#deploy-ink-contract-to-testnet","title":"Deploy ink! contract to testnet","text":"<p>To deploy ink! contracts to testnet, install cargo-contract https://github.com/paritytech/cargo-contract</p>"},{"location":"builders/develop-with-qp/","title":"Develop using Quantum Portal","text":""},{"location":"builders/develop-with-qp/#overview","title":"Overview","text":"<p>Quantum Portal is a smart contract framework that enables interoperability and communication between different blockchains. Solidity developers can utilize Quantum Portal in their contracts to interact with contracts on other chains.</p> <p>Quantum Portal allows contracts to execute methods on remote contracts located on different blockchains.It enables value transfers, method calls, and balance transfers between chains.</p> <p>Developers can use Quantum Portal to build cross-chain functionalities and integrate with contracts on other chains.</p>"},{"location":"builders/develop-with-qp/#key-components","title":"Key Components","text":"<ul> <li><code>QuantumPortalPoc</code>: An abstract contract that provides the main functionality for Quantum Portal.</li> <li>It inherits from <code>TokenReceivable</code> and <code>PortalLedger</code> contracts.</li> <li><code>TokenReceivable</code> handles token transfers, and <code>PortalLedger</code> manages transaction registration and balance tracking.</li> </ul>"},{"location":"builders/develop-with-qp/#usage","title":"Usage","text":"<ul> <li>Solidity developers can inherit from <code>QuantumPortalPoc</code> to incorporate Quantum Portal into their contracts.</li> <li>The <code>run</code> function allows executing a method on a remote contract without value transfer.</li> <li>The <code>runWithValue</code> function executes a remote method and pays a specified token amount to the remote contract.</li> <li>The <code>runWithdraw</code> function performs a remote withdraw, updating the user's balance for subsequent withdrawals.</li> <li>The <code>remoteTransfer</code> function transfers the remote balance of a token to another account within a mining context.</li> <li>The <code>withdraw</code> function enables users to withdraw their remote balance.</li> <li>The <code>msgSender</code> function retrieves information about the current context, including the source network, message sender, and beneficiary.</li> </ul>"},{"location":"builders/develop-with-qp/#your-first-contract","title":"Your First Contract","text":"<p>For the fist example lets build a simple ping-pong contract, the contract will send a ping message to a remote contract deployed on another network and the pong contract will receive the ping message and send a pong message back to the caller.</p> <p></p>"},{"location":"builders/develop-with-qp/#pong-contract","title":"Pong Contract","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"quantum-portal-smart-contracts/contracts/quantumPortal/poc/IQuantumPortalPoc.sol\";\nimport \"quantum-portal-smart-contracts/contracts/quantumPortal/poc/IQuantumPortalFeeManager.sol\";\n\n/**\n * @title Pong\n * @dev A smart contract that handles pinging and ponging between contracts using Quantum Portal.\n */\ncontract Pong  {\n    uint256 public CHAIN_ID;\n    IQuantumPortalPoc public portal;\n    mapping (address =&gt; uint) public pings;\n    address public pingContract;\n\n    constructor() {\n        initialize();\n    }\n\n    /**\n     * @dev Initializes the Pong contract.\n     */\n    function initialize() internal virtual {\n        uint256 overrideChainID; // for test only. provide 0 outside a test\n        address portal_address;\n        portal = IQuantumPortalPoc(portal_address);\n        CHAIN_ID = overrideChainID == 0 ? block.chainid : overrideChainID;\n    }\n\n    /**\n     * @notice This function should be called by the QuantumPortal.\n     * @dev Handles the ping event triggered by the QuantumPortal.\n     */\n    function pingRemote() external {\n        // caller is QP\n        (uint netId, address sourceMsgSender, address beneficiary) = portal.msgSender();\n        // ensure the caller is the ping contract\n        require(sourceMsgSender == pingContract, \"Caller not expected!\");\n        pings[sourceMsgSender] += 1;\n    }\n\n    /**\n     * @dev Sends a pong response to the recipient on a specific chain.\n     * @param recipient The address of the recipient to send the pong response.\n     * @param chainId The ID of the chain on which the pong response is sent.\n     */\n    function pong(address recipient, uint256 chainId) external {\n        pings[recipient] -= 1;\n        bytes memory method = abi.encodeWithSelector(Ping.remotePong.selector);\n        // Call the QuantumPortal to run the specified method on the given chain and contract\n        portal.run(\n            uint64(chainId), pingContract, msg.sender, method);\n    }\n\n    /**\n     * @dev Sets the address of the ping contract.\n     * @param contractAddress The address of the ping contract.\n     */\n    function setPingContractAddress(address contractAddress) external {\n        pingContract = contractAddress;\n    }\n}\n</code></pre>"},{"location":"builders/develop-with-qp/#ping-contract","title":"Ping Contract","text":"<pre><code>pragma solidity ^0.8.0;\nimport \"quantum-portal-smart-contracts/contracts/quantumPortal/poc/IQuantumPortalPoc.sol\";\nimport \"quantum-portal-smart-contracts/contracts/quantumPortal/poc/IQuantumPortalFeeManager.sol\";\n/**\n * @title Ping\n * @dev A smart contract that handles pinging and ponging between contracts using Quantum Portal.\n */\ncontract Ping {\n    IQuantumPortalPoc public portal;\n    uint256 public MASTER_CHAIN_ID = 26000; // The FRM chain ID\n    address public PongContract;\n    mapping (address =&gt; uint) public pongs;\n\n    constructor() {\n        initialize();\n    }\n\n    /**\n     * @dev Initializes the Ping contract.\n     */\n    function initialize() internal virtual {\n        uint256 overrideChainID; // for test only. provide 0 outside a test\n        address portal_address;\n        portal = IQuantumPortalPoc(portal_address);\n    }\n\n    /**\n     * @dev Initiates the ping event.\n     */\n    function ping() external {\n        bytes memory method = abi.encodeWithSelector(Pong.pingRemote.selector);\n        portal.run(\n            0, uint64(MASTER_CHAIN_ID), PongContract, msg.sender, method);\n    }\n\n    /**\n     * @dev Handles the pong event triggered by the QuantumPortal.\n     * @param recipient The address of the recipient of the pong event.\n     */\n    function remotePong(address recipient) external {\n        pongs[recipient] += 1;\n    }\n}\n</code></pre> <p>You can view the full example here : https://github.com/ferrumnet/quantum-portal-tutorial-code-and-examples</p>"},{"location":"builders/getting-started/","title":"Getting Started","text":""},{"location":"builders/getting-started/#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Connecting to Ferrum Network</li> <li>Requesting Testnet tokens</li> <li>Transferring tokens</li> <li>Verifying Transactions</li> </ul>"},{"location":"builders/getting-started/#connecting-to-ferrum-network","title":"Connecting to ferrum network","text":""},{"location":"builders/getting-started/#1-using-polkadotjs","title":"1. Using PolkadotJS","text":"<p>Ferrum network is available at testnet.dev.svcs.ferrumnetwork.io</p> <p>You should be able to view the network like below : </p> <p></p>"},{"location":"builders/getting-started/#2-using-metamask","title":"2. Using Metamask","text":"<p>To connect your metamask to Ferrum network, use the below configuration</p> <pre><code>Network Name : Ferrum Testnet\n\nRPC URL : https://testnet.dev.svcs.ferrumnetwork.io/rpc/\n\nChainId : 26100\n\nCurrency : tFRM\n</code></pre> <p>The config should look like this :</p> <p></p>"},{"location":"builders/getting-started/#requesting-testnet-tokens","title":"Requesting Testnet tokens","text":"<p>You can use the below faucet to request testnet tokens : </p> <p>https://testnet.faucet.ferrumnetwork.io/</p>"},{"location":"builders/getting-started/#transferring-tokens","title":"Transferring tokens","text":"<p>Ferrum network parachain supports all evm transactions, so transferring tFRM tokens should be like transferring any other erc20 token :</p> <p>To transfer tFRM token on the Ferrum network, switch your metamask to <code>Ferrum Testnet</code></p> <p></p> <p>Enter the destination address and amount and confirm the transfer</p> <p></p>"},{"location":"builders/getting-started/#verifying-transactions","title":"Verifying transactions","text":"<p>All transactions (both substrate and evm transactions) can be seen on the ferrum explorer at testnet.dev.svcs.ferrumnetwork.io</p> <p>In the above case, if you navigate to the explorer, you should see the transfer events on the network tab like below :</p> <p></p> <p>If you click on any event, you should see the details of that event :</p> <p></p>"},{"location":"learn/quantum-portal/","title":"Quantum Portal","text":""},{"location":"learn/quantum-portal/#how-quantum-portal-works","title":"How Quantum Portal works","text":"<p>Quantum Portal is part of the Ferrum Runtime Node. When you deploy the Ferrum Network node you can configure it to mine or validate Quantum Portal transactions of Ferrum Network transactions as a collator on the network.</p>"},{"location":"learn/quantum-portal/#overview","title":"Overview","text":"<p>Quantum Portal is part of the Ferrum Runtime Node. When you deploy the Ferrum Network node you can configure it to mine or validate Quantum Portal transactions of Ferrum Network transactions as a collator on the network.</p> <p>Quantum Portal includes the following core components:</p> <ol> <li>QP Smart Contract</li> <li>QP Miner</li> <li>QP Finalizer</li> </ol> <p></p>"},{"location":"learn/quantum-portal/#what-is-quantum-portal-mining","title":"What is Quantum Portal Mining?","text":"<p>The QP Miners take turns based on an algorithm to create and relay these blocks from the sourceChain to the destinationChain. QP Miners do this by running the Ferrum Node as a QP Miner (QP Node). Once configured, this QP Node monitors the transactions on the network that they have set up to be miners and staked tokens on. The QP Node monitors transactions on the sourceChain and if new data is available, it creates a block every 15 seconds. After creating a block, the QP Node calls the mineRemoteBlock on the destinationChain in order to execute the transaction and mine the QP Block. It is considered a mined block after the transaction executes on the destinationChain</p>"},{"location":"learn/quantum-portal/#what-is-quantum-portal-finalisation","title":"What is Quantum Portal Finalisation?","text":"<p>The QP collators take turns based on an algorithm to pick the pending (mined but not finalized) Quantum Portal Blocks from the Quantum Portal Mined Block mempool. QP collators do this by running the Ferrum Node as a QP collator (QP Node). Once configured, this QP Node monitors the Quantum Portal Mined Block mempool for mined Quantum Portal Blocks, If new data is available, it creates a finalized block every 15 seconds. After creating a finalized block, the QP Node calls the finalizeRemoteBlock on the destinationChain in order to record the block as finalized and execute any remote transactions if applicable. The QP Block. It is considered a finalized block after the finalizeRemoteBlock transaction executes on the destinationChain Once mined QP Blocks are finalized, the record of the finalized mined blocks and the finalized block itself is added to the destinationChains.</p>"},{"location":"learn/roles/","title":"Roles","text":""},{"location":"learn/roles/#introduction","title":"Introduction","text":"<p>Collators/collators are members of the network that maintain the parachains they take part in. They run a full node (for both their particular parachain and the relay chain), and they produce the state transition proof for relay chain collators.</p> <p>Candidates will need a minimum amount of tokens bonded (self-bonded) to be considered eligible. Along with running a collator node for the ferrum blockchain, you can choose to run a specific type of Ferrum node, which help in validating cross chain transactions on the ferrum network.</p>"},{"location":"learn/roles/#types-of-nodes","title":"Types of Nodes","text":"<p>The different types of nodes of ferrum network:</p> <ol> <li> <p>Collator node</p> <p>Running a collator node means you pariticipate in the block production of ferrum network. Once your collator node is up and running, you can choose to be a block producer candidate, and if you have a minimum amount of tokens you would be selected for block production. Currently we do not have staking or rewards for block production but we plan to support this in the future.</p> </li> <li> <p>Miner Node (QP Miner)</p> <p>A miner node is responsible for mining cross chain transactions, these nodes will observe the qp chain pairs and mine blocks on each other chains. This type of node can be run in conjunction with a collator node or indepdently to mine the block on the pair chain. Do note that running this node requires a minimum amount of tokens to pay for transaction costs on the pair chains.</p> </li> <li> <p>Finalizer Node (QP Finalizer)</p> <p>The finalizer node is responsible for finalizing the mined blocks, these nodes will observe the mined blocks on the pair chains and finalize the block on the pair chain. This type of node can be run in conjunction with a collator node or indepdently to finalize the block on the pair chain. Do note that running this node requires a minimum amount of tokens to pay for transaction costs on the pair chains.</p> </li> <li> <p>Archive Node</p> <p>The archive node is the simplest type of node, the node will sync and update the latest block on the ferrum chain. This type of node is useful to run an indexer or explorer.</p> </li> </ol>"},{"location":"node-operators/running-archive-node/","title":"Running Ferrum archive node","text":"<p>This guide assumes you have followed the instructions to setup your node here.</p>"},{"location":"node-operators/running-archive-node/#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Run using docker</li> <li>Run using binary</li> </ul>"},{"location":"node-operators/running-archive-node/#run-using-docker","title":"Run using docker","text":"<p>Follow the below instructions, to setup your miner node to connect to Ferrum testnet</p> <ol> <li>Build the docker image using:</li> </ol> <pre><code>docker build -t ferrum_node -f docker/ferrum.Dockerfile .\n</code></pre> <ol> <li>Next, make sure you set the ownership and permissions accordingly for the local directory that stores the chain data. In this case, set the necessary permissions either for a specific or current user (replace DOCKER_USER for the actual user that will run the docker command):</li> </ol> <pre><code># chown to a specific user\nmkdir /var/lib/ferrum-data\nchown DOCKER_USER /var/lib/ferrum-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/ferrum-data\n</code></pre> <ol> <li>Now, execute the docker run command depending on your configuration : </li> </ol> <pre><code>docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nferrum_node \\\n--base-path=/data \\\n--chain ./chainspecs/ferrum-alpha-testnet \\\n--name=\"YOUR-NODE-NAME\" \\\n--pruning archive \\\n--config-file-path=/var/lib/node-config.json\n-- \\\n--execution wasm \\\n--name=\"YOUR-NODE-NAME (Embedded Relay)\"\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-archive-node/#run-using-binary","title":"Run using binary","text":"<ol> <li> <p>Install the required dependencies to compile rust and substrate, refer the documentation here : https://docs.substrate.io/install/</p> </li> <li> <p>Clone the ferrum-network repo</p> </li> </ol> <pre><code>https://github.com/ferrumnet/ferrum-network.git\n</code></pre> <ol> <li>Checkout the latest release</li> </ol> <pre><code>cd ferrum-network\ngit checkout tags/&lt;release_version&gt; -b &lt;release_version&gt;\n</code></pre> <p>For example, if the latest release is 0.0.3</p> <pre><code>git checkout tags/0.0.3 -b v0.0.3\n</code></pre> <p>You can checkout releases here : https://github.com/ferrumnet/ferrum-network/releases</p> <ol> <li>Build the binary</li> </ol> <pre><code>cargo build --release\n</code></pre> <ol> <li>Insert the keys</li> </ol> <pre><code>./target/release/ferrum-network key insert --key-type ofsg --scheme Ecdsa --base-path /var/lib/ferrum-data\n</code></pre> <ol> <li>Once the keys are inserted, you can run it using the following command</li> </ol> <pre><code>./target/release/ferrum-network \\\n--base-path=/var/lib/ferrum-data \\\n--chain ./chainspecs/ferrum-alpha-testnet \\\n--name=\"YOUR-NODE-NAME\" \\\n--pruning archive \\\n-config-file-path node-config.json\n-execution wasm \\\n-- \\\n--execution wasm \\\n--name=\"YOUR-NODE-NAME (Embedded Relay)\"\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-collator-node/","title":"Running Ferrum collator node","text":"<p>This guide assumes you have followed the instructions to setup your node here.</p>"},{"location":"node-operators/running-collator-node/#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Run using docker</li> <li>Run using binary</li> </ul>"},{"location":"node-operators/running-collator-node/#run-using-docker","title":"Run using docker","text":"<p>Follow the below instructions, to setup your miner node to connect to Ferrum testnet</p> <ol> <li>Build the docker image using:</li> </ol> <pre><code>docker build -t ferrum_node -f docker/ferrum.Dockerfile .\n</code></pre> <ol> <li>Next, make sure you set the ownership and permissions accordingly for the local directory that stores the chain data. In this case, set the necessary permissions either for a specific or current user (replace DOCKER_USER for the actual user that will run the docker command):</li> </ol> <pre><code># chown to a specific user\nmkdir /var/lib/ferrum-data\nchown DOCKER_USER /var/lib/ferrum-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/ferrum-data\n</code></pre> <ol> <li> <p>Before you can start the node, you have to insert the keys, do note that this step depends on the type of node you are running</p> <p>You need to insert the AURA key for the collator account to author blocks, this can be done using</p> <p>```bash docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\ ferrum/ferrum_node:latest \\ key insert --key-type aura --scheme Sr25519 --base-path=/data</p> </li> <li> <p>Now, execute the docker run command depending on your configuration : </p> </li> </ol> <pre><code>docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nferrum-network \\\n--base-path=/data \\\n--chain ./chainspecs/ferrum-alpha-testnet \\\n--name=\"YOUR-NODE-NAME\" \\\n--collator \\\n--config-file-path=/var/lib/node-config.json\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-collator-node/#run-using-binary","title":"Run using binary","text":"<ol> <li> <p>Install the required dependencies to compile rust and substrate, refer the documentation here : https://docs.substrate.io/install/</p> </li> <li> <p>Clone the ferrum-network repo</p> </li> </ol> <pre><code>https://github.com/ferrumnet/ferrum-network.git\n</code></pre> <ol> <li>Checkout the latest release</li> </ol> <pre><code>cd ferrum-network\ngit checkout tags/&lt;release_version&gt; -b &lt;release_version&gt;\n</code></pre> <p>For example, if the latest release is 0.0.3</p> <pre><code>git checkout tags/0.0.3 -b v0.0.3\n</code></pre> <p>You can checkout releases here : https://github.com/ferrumnet/ferrum-network/releases</p> <ol> <li>Build the binary</li> </ol> <pre><code>cargo build --release\n</code></pre> <ol> <li>Insert the keys</li> </ol> <pre><code>./target/release/ferrum-network key insert --key-type aura --scheme Sr25519 --base-path /var/lib/ferrum-data\n</code></pre> <ol> <li>Once the keys are inserted, you can run it using the following command</li> </ol> <pre><code>./target/release/ferrum-network \\\n--base-path &lt;PATH_TO_CHAIN_STORAGE&gt; \\\n--chain ./chainspecs/testnet-alpha.json \\\n--name \"YOUR-NODE-NAME\" \\\n--collator \\\n--config-file-path &lt;PATH_TO_YOUR_NODE_CONFIG&gt; \\\n--execution=wasm \\\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-finalizer-node/","title":"Running a QP finalizer node","text":"<p>This guide assumes you have followed the instructions to setup your node here.</p> <p>External miners are not supported in the current ferrum testnet, we will announce once we start onboarding finalizers!.</p>"},{"location":"node-operators/running-finalizer-node/#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Prerequisites</li> <li>Run using docker</li> <li>Run using binary</li> </ul>"},{"location":"node-operators/running-finalizer-node/#prerequisites","title":"Prerequisites","text":""},{"location":"node-operators/running-finalizer-node/#setup-config-file","title":"Setup Config file","text":"<p>Running a QP node requires setting up the configuration for the sourcechain and destinationchain pairs, it is essential to set these values up correctly or the transactions will fail.</p> <p>These are the values to be included in the file : </p> <pre><code>{\n    \"networks\": {\n        \"network_vec\": [{\n            \"url\": \"&lt;CHAIN_1_RPC_URL&gt;\",\n            \"gateway_contract_address\": \"&lt;CHAIN_1_LEDGER_MGR_ADDRESS&gt;\",\n            \"id\": \"CHAIN_1_ID\"\n        },\n        {\n            \"url\": \"&lt;CHAIN_2_RPC_URL&gt;\",\n            \"gateway_contract_address\": \"&lt;CHAIN_2_LEDGER_MGR_ADDRESS&gt;\",\n            \"id\": \"CHAIN_2_ID\"\n        }],\n        \"pair_vec\": [[CHAIN_1_ID, CHAIN_2_ID], [CHAIN_1_ID, CHAIN_2_ID]],\n        \"signer_public_key\": \"PUB_KEY\",\n        \"role\" : \"&lt;NODE_ROLE&gt;\"\n    }\n}\n</code></pre> <p>Values explained : </p> <ul> <li>The network_vec contains the list of chains that the miner/finaliser will connect to, this should include the url of the chain, the qp ledger manager address and the chain id of the respective chain.</li> <li>signer_public_key contains the public key of the address you will use to sign the mine/finalise transactions, do ensure that the address has balance to execute the transactions on both chains.</li> <li>authority_manager_contract_addres refers to the address of the QP authority manager contract.</li> <li>NODE_ROLE signifies the role you choose for the node, it should be one of <code>QP_FINALIZER</code> or <code>QP_MINER</code></li> </ul> <p>An example config for finalizing between Mumbai testnet and BSC testnet would be as follows : </p> <pre><code>{\n    \"networks\": {\n        \"network_vec\": [{\n            \"url\": \"https://rpc-mumbai.maticvigil.com/\",\n            \"gateway_contract_address\": \"1AC9Fb66D542FEe49728e0da6af230dbECD6d547\",\n            \"id\": 80001\n        },\n        {\n            \"url\": \"https://data-seed-prebsc-2-s3.binance.org:8545\",\n            \"gateway_contract_address\": \"1AC9Fb66D542FEe49728e0da6af230dbECD6d547\",\n            \"id\": 97\n        }],\n        \"pair_vec\": [[80001, 97], [97, 80001]],\n        \"signer_public_key\": \"0x000000000000\",\n        \"role\" : \"QP_FINALIZER\"\n    }\n}\n</code></pre> <p>Setup the config and save it to a file called <code>node-config.json</code></p>"},{"location":"node-operators/running-finalizer-node/#setup-signer-keys","title":"Setup signer keys","text":"<p>Follow the instructions hereto generate a signer key, this key will be signing and mining all transactions, so make sure you store it carefully.</p>"},{"location":"node-operators/running-finalizer-node/#run-using-docker","title":"Run using docker","text":"<p>Follow the below instructions, to setup your miner node to connect to Ferrum testnet</p> <ol> <li>Build the docker image using:</li> </ol> <pre><code>docker build -t ferrum_node -f docker/ferrum.Dockerfile .\n</code></pre> <ol> <li>Next, make sure you set the ownership and permissions accordingly for the local directory that stores the chain data. In this case, set the necessary permissions either for a specific or current user (replace DOCKER_USER for the actual user that will run the docker command):</li> </ol> <pre><code># chown to a specific user\nmkdir /var/lib/ferrum-data\nchown DOCKER_USER /var/lib/ferrum-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/ferrum-data\n</code></pre> <ol> <li> <p>Before you can start the node, you have to insert the keys</p> <p>You need to insert the ofsg key for the account to sign and post transactions on the QP chains</p> <p><code>bash docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\ ferrum/ferrum_node:latest \\ key insert --key-type ofsg --scheme Ecdsa --base-path=/data</code></p> <p>The CLI will ask you to enter the keys, enter the key generated in the previous step.</p> </li> <li> <p>Now, execute the docker run command depending on your configuration : </p> </li> </ol> <pre><code>docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nferrum_node \\\n--base-path=/data \\\n--chain ./chainspecs/ferrum-alpha-testnet \\\n--name=\"YOUR-NODE-NAME\" \\\n--config-file-path=/var/lib/node-config.json\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-finalizer-node/#run-using-binary","title":"Run using binary","text":"<ol> <li> <p>Install the required dependencies to compile rust and substrate, refer the documentation here : https://docs.substrate.io/install/</p> </li> <li> <p>Clone the ferrum-network repo</p> </li> </ol> <pre><code>https://github.com/ferrumnet/ferrum-network.git\n</code></pre> <ol> <li>Checkout the latest release</li> </ol> <pre><code>cd ferrum-network\ngit checkout tags/&lt;release_version&gt; -b &lt;release_version&gt;\n</code></pre> <p>For example, if the latest release is 0.0.3</p> <pre><code>git checkout tags/0.0.3 -b v0.0.3\n</code></pre> <p>You can checkout releases here : https://github.com/ferrumnet/ferrum-network/releases</p> <ol> <li>Build the binary</li> </ol> <pre><code>cargo build --release\n</code></pre> <ol> <li>Insert the keys</li> </ol> <pre><code>./target/release/ferrum-network key insert --key-type ofsg --scheme Ecdsa --base-path /var/lib/ferrum-data\n</code></pre> <ol> <li>Once the keys are inserted, you can run it using the following command</li> </ol> <pre><code>./target/release/ferrum-network \\\n--base-path &lt;PATH_TO_CHAIN_STORAGE&gt; \\\n--chain ./chainspecs/testnet-alpha.json \\\n--name \"YOUR-NODE-NAME\" \\\n--config-file-path &lt;PATH_TO_YOUR_NODE_CONFIG&gt; \\\n--execution=wasm \\\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-miner-node/","title":"Running a QP miner node","text":"<p>This guide assumes you have followed the instructions to setup your node here.</p>"},{"location":"node-operators/running-miner-node/#table-of-contents","title":"Table of Contents:","text":"<ul> <li>Prerequisites</li> <li>Run using docker</li> <li>Run using binary</li> </ul>"},{"location":"node-operators/running-miner-node/#prerequisites","title":"Prerequisites","text":""},{"location":"node-operators/running-miner-node/#setup-config-file","title":"Setup Config file","text":"<p>Running a QP node requires setting up the configuration for the sourcechain and destinationchain pairs, it is essential to set these values up correctly or the transactions will fail.</p> <p>These are the values to be included in the file : </p> <pre><code>{\n    \"networks\": {\n        \"network_vec\": [{\n            \"url\": \"&lt;CHAIN_1_RPC_URL&gt;\",\n            \"gateway_contract_address\": \"&lt;CHAIN_1_LEDGER_MGR_ADDRESS&gt;\",\n            \"id\": \"CHAIN_1_ID\"\n        },\n        {\n            \"url\": \"&lt;CHAIN_2_RPC_URL&gt;\",\n            \"gateway_contract_address\": \"&lt;CHAIN_2_LEDGER_MGR_ADDRESS&gt;\",\n            \"id\": \"CHAIN_2_ID\"\n        }],\n        \"pair_vec\": [[CHAIN_1_ID, CHAIN_2_ID], [CHAIN_1_ID, CHAIN_2_ID]],\n        \"signer_public_key\": \"PUB_KEY\",\n        \"role\" : \"&lt;NODE_ROLE&gt;\"\n    }\n}\n</code></pre> <p>Values explained : </p> <ul> <li>The network_vec contains the list of chains that the miner/finaliser will connect to, this should include the url of the chain, the qp ledger manager address and the chain id of the respective chain.</li> <li>signer_public_key contains the public key of the address you will use to sign the mine/finalise transactions, do ensure that the address has balance to execute the transactions on both chains.</li> <li>authority_manager_contract_addres refers to the address of the QP authority manager contract.</li> <li>NODE_ROLE signifies the role you choose for the node, it should be one of <code>QP_FINALIZER</code> or <code>QP_MINER</code></li> </ul> <p>An example config for mining between Mumbai testnet and BSC testnet would be as follows : </p> <pre><code>{\n    \"networks\": {\n        \"network_vec\": [{\n            \"url\": \"https://rpc-mumbai.maticvigil.com/\",\n            \"gateway_contract_address\": \"1AC9Fb66D542FEe49728e0da6af230dbECD6d547\",\n            \"id\": 80001\n        },\n        {\n            \"url\": \"https://data-seed-prebsc-2-s3.binance.org:8545\",\n            \"gateway_contract_address\": \"1AC9Fb66D542FEe49728e0da6af230dbECD6d547\",\n            \"id\": 97\n        }],\n        \"pair_vec\": [[80001, 97], [97, 80001]],\n        \"signer_public_key\": \"0x000000000000\",\n        \"role\" : \"QP_MINER\"\n    }\n}\n</code></pre> <p>Setup the config and save it to a file called <code>node-config.json</code></p>"},{"location":"node-operators/running-miner-node/#setup-signer-keys","title":"Setup signer keys","text":"<p>Follow the instructions hereto generate a signer key, this key will be signing and mining all transactions, so make sure you store it carefully.</p>"},{"location":"node-operators/running-miner-node/#run-using-docker","title":"Run using docker","text":"<p>Follow the below instructions, to setup your miner node to connect to Ferrum testnet</p> <ol> <li>Build the docker image using:</li> </ol> <pre><code>docker build -t ferrum_node -f docker/ferrum.Dockerfile .\n</code></pre> <ol> <li>Next, make sure you set the ownership and permissions accordingly for the local directory that stores the chain data. In this case, set the necessary permissions either for a specific or current user (replace DOCKER_USER for the actual user that will run the docker command):</li> </ol> <pre><code># chown to a specific user\nmkdir /var/lib/ferrum-data\nchown DOCKER_USER /var/lib/ferrum-data\n\n# chown to current user\nsudo chown -R $(id -u):$(id -g) /var/lib/ferrum-data\n</code></pre> <ol> <li> <p>Before you can start the node, you have to insert the keys</p> <p>You need to insert the ofsg key for the account to sign and post transactions on the QP chains</p> <p><code>bash docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\ ferrum/ferrum_node:latest \\ key insert --key-type ofsg --scheme Ecdsa --base-path=/data</code></p> <p>The CLI will ask you to enter the keys, enter the key generated in the previous step.</p> </li> <li> <p>Now, execute the docker run command depending on your configuration : </p> </li> </ol> <pre><code>docker run --network=\"host\" -v \"/var/lib/ferrum-data:/data\" \\\n-u $(id -u ${USER}):$(id -g ${USER}) \\\nferrum_node \\\n--base-path=/data \\\n--chain ./chainspecs/ferrum-alpha-testnet \\\n--name=\"YOUR-NODE-NAME\" \\\n--collator \\\n--config-file-path=/var/lib/node-config.json\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-miner-node/#run-using-binary","title":"Run using binary","text":"<ol> <li> <p>Install the required dependencies to compile rust and substrate, refer the documentation here : https://docs.substrate.io/install/</p> </li> <li> <p>Clone the ferrum-network repo</p> </li> </ol> <pre><code>https://github.com/ferrumnet/ferrum-network.git\n</code></pre> <ol> <li>Checkout the latest release</li> </ol> <pre><code>cd ferrum-network\ngit checkout tags/&lt;release_version&gt; -b &lt;release_version&gt;\n</code></pre> <p>For example, if the latest release is 0.0.3</p> <pre><code>git checkout tags/0.0.3 -b v0.0.3\n</code></pre> <p>You can checkout releases here : https://github.com/ferrumnet/ferrum-network/releases</p> <ol> <li>Build the binary</li> </ol> <pre><code>cargo build --release\n</code></pre> <ol> <li>Insert the keys</li> </ol> <pre><code>./target/release/ferrum-network key insert --key-type ofsg --scheme Ecdsa --base-path /var/lib/ferrum-data\n</code></pre> <ol> <li>Once the keys are inserted, you can run it using the following command</li> </ol> <pre><code>./target/release/ferrum-network \\\n--base-path &lt;PATH_TO_CHAIN_STORAGE&gt; \\\n--chain ./chainspecs/testnet-alpha.json \\\n--name \"YOUR-NODE-NAME\" \\\n--config-file-path &lt;PATH_TO_YOUR_NODE_CONFIG&gt; \\\n--execution=wasm \\\n-- \\\n--chain ./chainspecs/testnet-relaychain.json\n</code></pre> <p>Once the node has started, your output should look similar to this</p> <pre><code>2023-04-28 17:22:41 Ferrum Parachain    \n2023-04-28 17:22:41 \u270c\ufe0f  version 0.0.1-742b47b9d10    \n2023-04-28 17:22:41 \u2764\ufe0f  by Ferrum Network &lt;https://github.com/ferrumnet&gt;, 2020-2023    \n2023-04-28 17:22:41 \ud83d\udccb Chain specification: Ferrum Testnet    \n2023-04-28 17:22:41 \ud83c\udff7  Node name: TestNode    \n2023-04-28 17:22:41 \ud83d\udc64 Role: AUTHORITY    \n2023-04-28 17:22:41 \ud83d\udcbe Database: RocksDb at ./chain/alice/chains/ferrum_testnet/db/full    \n2023-04-28 17:22:41 \u26d3  Native runtime: ferrum-parachain-1 (ferrum-parachain-0.tx1.au1)    \n2023-04-28 17:22:43 assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 assembling new collators for new session 1 at #0    \n2023-04-28 17:22:43 Parachain id: Id(1000)    \n2023-04-28 17:22:43 Parachain Account: 5Ec4AhPZk8STuex8Wsi9TwDtJQxKqzPJRCH7348Xtcs9vZLJ    \n2023-04-28 17:22:43 Parachain genesis state: 0x000000000000000000000000000000000000000000000000000000000000000000cb981b199b0dfb2631bbac63b767890daad314c0ce7b0d681e0fa76354a9b89803170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131400    \n2023-04-28 17:22:43 Is collating: yes    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 0 at #0    \n2023-04-28 17:22:43 [Parachain] assembling new collators for new session 1 at #0    \n</code></pre> <p>Depending on how long the testnet has been running, your node will take a while to sync with the latest state of the network.</p>"},{"location":"node-operators/running-nodes/","title":"Run a Ferrum Testnet Node","text":""},{"location":"node-operators/running-nodes/#introduction","title":"Introduction","text":"<p>Collators/collators are members of the network that maintain the parachains they take part in. They run a full node (for both their particular parachain and the relay chain), and they produce the state transition proof for relay chain collators.</p> <p>Candidates will need a minimum amount of tokens bonded (self-bonded) to be considered eligible. Along with running a collator node for the ferrum blockchain, you can choose to run a specific type of Ferrum node, which help in validating cross chain transactions on the ferrum network.</p>"},{"location":"node-operators/running-nodes/#types-of-nodes","title":"Types of Nodes","text":"<p>The different types of nodes of ferrum network:</p> <ol> <li> <p>Collator node</p> <p>Running a collator node means you pariticipate in the block production of ferrum network. Once your collator node is up and running, you can choose to be a block producer candidate, and if you have a minimum amount of tokens you would be selected for block production. Currently we do not have staking or rewards for block production but we plan to support this in the future.</p> </li> <li> <p>Miner Node (QP Miner)</p> <p>A miner node is responsible for mining cross chain transactions, these nodes will observe the qp chain pairs and mine blocks on each other chains. This type of node can be run in conjunction with a collator node or indepdently to mine the block on the pair chain. Do note that running this node requires a minimum amount of tokens to pay for transaction costs on the pair chains.</p> </li> <li> <p>Finalizer Node (QP Finalizer)</p> <p>The finalizer node is responsible for finalizing the mined blocks, these nodes will observe the mined blocks on the pair chains and finalize the block on the pair chain. This type of node can be run in conjunction with a collator node or indepdently to finalize the block on the pair chain. Do note that running this node requires a minimum amount of tokens to pay for transaction costs on the pair chains.</p> </li> <li> <p>Archive Node</p> <p>The archive node is the simplest type of node, the node will sync and update the latest block on the ferrum chain. This type of node is useful to run an indexer or explorer.</p> </li> </ol>"},{"location":"node-operators/running-nodes/#system-requirements","title":"System Requirements","text":"<p>The most common way for a beginner to run a validator is on a cloud server running Linux. You may choose whatever VPS provider that your prefer. As OS it is best to use a recent Debian Linux. For this guide we will be using Ubuntu 22.04, but the instructions should be similar for other platforms.</p>"},{"location":"node-operators/running-nodes/#reference-hardware","title":"Reference Hardware","text":"<p>The transaction weights in Polkadot are benchmarked on reference hardware. We ran the benchmark on VM instances of two major cloud providers: Google Cloud Platform (GCP) and Amazon Web Services (AWS). To be specific, we used c2d-highcpu-8 VM instance on GCP and c6id.2xlarge on AWS. It is recommended that the hardware used to run the validators at least matches the specs of the reference hardware in order to ensure they are able to process all blocks in time. If you use subpar hardware you will possibly run into performance issues, get less era points, and potentially even get slashed.</p>"},{"location":"node-operators/running-nodes/#cpu","title":"CPU","text":"<p>x86-64 compatible; Intel Ice Lake, or newer (Xeon or Core series); AMD Zen3, or newer (EPYC or Ryzen); 4 physical cores @ 3.4GHz; Simultaneous multithreading disabled (Hyper-Threading on Intel, SMT on AMD); Prefer single-threaded performance over higher cores count. A comparison of single-threaded performance can be found here.</p>"},{"location":"node-operators/running-nodes/#storage","title":"Storage","text":"<p>An NVMe SSD of 1 TB (As it should be reasonably sized to deal with blockchain growth). An estimation of current chain snapshot sizes can be found here. In general, the latency is more important than the throughput.</p>"},{"location":"node-operators/running-nodes/#memory","title":"Memory","text":"<p>16GB DDR4 ECC. System Linux Kernel 5.16 or newer.</p>"},{"location":"node-operators/running-nodes/#network","title":"Network","text":"<p>The minimum symmetric networking speed is set to 500 Mbit/s (= 62.5 MB/s). This is required to support a large number of parachains and allow for proper congestion control in busy network situations.</p> <p>The specs posted above are not a hard requirement to run a collator, but are considered best practice. Running a collator is a responsible task; using professional hardware is a must in any way.</p>"},{"location":"node-operators/running-nodes/#account-requirements","title":"Account Requirements","text":"<p>Similar to Polkadot validators, you need to create an account. For Ferrum, this is an H160 account or an Ethereum-style account from which you hold the private keys. As a collator, you are responsible for correctly managing your own keys. Incorrectly doing so can result in a loss of funds.</p> <p>There are many Ethereum wallets that can be used, but for production purposes it is recommended to generate keys as securely as possible. It is also recommended to generate backup keys.</p> <p>To generate keys securely it is recommended to do so on an air-gapped machine. Once you generate your keys make sure you store them safely. To securely store your keys, here are some recommendations, from least to most secure:</p> <p>Write down and laminate your keys Engrave your keys into a metal plate Shard your keys using a tool like Horcrux As always, it is recommended to do your own research and use tools that you vet as trustworthy.</p>"},{"location":"node-operators/running-nodes/#node-prerequisites","title":"Node Prerequisites","text":"<p>Once you choose your cloud service provider and set-up your new server, the first thing you will do is install Rust.</p> <p>If you have never installed Rust, you should do this first.</p> <p>If you have already installed Rust, run the following command to make sure you are using the latest version.</p> <pre><code>rustup update\n</code></pre> <p>If not, this command will fetch the latest version of Rust and install it.</p> <pre><code>curl https://sh.rustup.rs -sSf | sh -s -- -y\n</code></pre> <p>Finally, run this command to install the necessary dependencies for compiling and running the Polkadot node software.</p> <pre><code>sudo apt install make clang pkg-config libssl-dev build-essential\n</code></pre>"},{"location":"node-operators/staking-miner/","title":"Miner Staking on Ferrum testnet","text":"<p>To become a miner on the ferrum testnet, you need to stake tFRM tokens, this stake is to ensure honest behavior of miners and to ensure equal participation to all miners on the network.</p> <p>For security reasons, it is recommended that you do not use the account associated with your miner on any hot wallet (like metamask), the keys to your miner has be stored safely. To ensure the safety of your primary miner key, the Ferrum Miner Staking contract allows you to delegate to any miner of your choice.</p> <p>This means that you can store your funds in a separate wallet and use that to stake, then delegate the stake to the miner account associated with your miner node.</p> <p>The steps for this would be :</p> <ol> <li>Stake on Ferrum mining manager contract</li> <li>Delegate to miner address</li> </ol> <p>To stake, you can use the testnet dashboard at https://testnet.faucet.ferrumnetwork.io/staking</p> <ol> <li>To stake tFRM tokens, select the client network you wish to mine, navigate to the stake tab and enter the amount of tokens to stake</li> </ol> <p></p> <ol> <li>Ensure your metamask wallet is on the same network as your selected network, and approve the transactions</li> </ol> <p></p> <ol> <li>Once the previous step has completed, you can delegate to the miner address. For this use the miner address you have supplied to the miner node.</li> </ol> <p></p>"}]}